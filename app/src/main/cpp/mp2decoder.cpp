#include <jni.h>
#include <stdio.h>
#include <string.h>
#include "mp2decoder.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    unsigned int pos;
    unsigned int num;
    unsigned int bits;
    unsigned int data;
} StreamBuffer;

typedef struct {
    unsigned int ID;
    unsigned int layer;
    unsigned int protection;
    unsigned int bitrate_index;
    unsigned int sampling_freq;
    unsigned int mode;
    unsigned int mode_extension;
    unsigned int copyright;
    unsigned int original_copy;
    unsigned int emphasis;
} AudioHeader;

typedef struct {
    unsigned char crc_word[4];
    unsigned int flag;
} CRC_WORDS;

typedef struct {
    unsigned int F_PAD_type;
    unsigned int F_PAD_type_ext;
    unsigned int X_PAD_Ind;
    unsigned int ByteL_Ind;
    unsigned int IH_Cmd_field;
    unsigned int M_S_flags;
    unsigned int Origin;
    unsigned int Serial_Cmd_field;
    unsigned int ByteL_data_field;
    unsigned int CI;
} F_PAD;

typedef struct {
    unsigned char Str[256];
    unsigned int num;
} TEXT;

typedef struct {
    unsigned int Toggle;
    unsigned int First_last;
    unsigned int Cmd_flag;
    unsigned int Length;
    unsigned int Cmd;
    unsigned int Charset;
    unsigned int SegNum;
} DynamicLabel;

#define FRACBITS        28
#define MUL(x, y)        ((x) >> 12) * ((y) >> 16)

StreamBuffer stream;
StreamBuffer CRC_stream;
unsigned char *audio_frame;
unsigned char *CRC_frame;
AudioHeader audio_header;
F_PAD f_pad;
TEXT text;
DynamicLabel d_label;
TEXT Label;
unsigned int label_flag = 0;
unsigned int Toggle = 2;
unsigned int change = 0;
unsigned int store = 0;

static CRC_WORDS sCRC_words = {0};
static int sN_ch = 0;
static int sSampling = 0;
static int sPCM_Length = 0;
static short sPCM_Frame[1152 * 2] = {0};
//static unsigned int sScaleFactor[2][32][3] = {0x3f};

const unsigned int Nbal[3][32] =
        {
                {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2,},
                {4, 4, 3, 3, 3, 3, 3, 3,},
                {4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,}
        };

/*
 * This is the lookup table for computing the CRC-check word.
 * As described in section 2.4.3.1 and depicted in Figure A.9
 * of ISO/IEC 11172-3, the generator polynomial is:
 *
 * G(X) = X^16 + X^15 + X^2 + 1
 */
#define CRC_POLY1  0x8005

const unsigned short crc_table1[256] = {
        0x0000, 0x8005, 0x800f, 0x000a, 0x801b, 0x001e, 0x0014, 0x8011,
        0x8033, 0x0036, 0x003c, 0x8039, 0x0028, 0x802d, 0x8027, 0x0022,
        0x8063, 0x0066, 0x006c, 0x8069, 0x0078, 0x807d, 0x8077, 0x0072,
        0x0050, 0x8055, 0x805f, 0x005a, 0x804b, 0x004e, 0x0044, 0x8041,
        0x80c3, 0x00c6, 0x00cc, 0x80c9, 0x00d8, 0x80dd, 0x80d7, 0x00d2,
        0x00f0, 0x80f5, 0x80ff, 0x00fa, 0x80eb, 0x00ee, 0x00e4, 0x80e1,
        0x00a0, 0x80a5, 0x80af, 0x00aa, 0x80bb, 0x00be, 0x00b4, 0x80b1,
        0x8093, 0x0096, 0x009c, 0x8099, 0x0088, 0x808d, 0x8087, 0x0082,

        0x8183, 0x0186, 0x018c, 0x8189, 0x0198, 0x819d, 0x8197, 0x0192,
        0x01b0, 0x81b5, 0x81bf, 0x01ba, 0x81ab, 0x01ae, 0x01a4, 0x81a1,
        0x01e0, 0x81e5, 0x81ef, 0x01ea, 0x81fb, 0x01fe, 0x01f4, 0x81f1,
        0x81d3, 0x01d6, 0x01dc, 0x81d9, 0x01c8, 0x81cd, 0x81c7, 0x01c2,
        0x0140, 0x8145, 0x814f, 0x014a, 0x815b, 0x015e, 0x0154, 0x8151,
        0x8173, 0x0176, 0x017c, 0x8179, 0x0168, 0x816d, 0x8167, 0x0162,
        0x8123, 0x0126, 0x012c, 0x8129, 0x0138, 0x813d, 0x8137, 0x0132,
        0x0110, 0x8115, 0x811f, 0x011a, 0x810b, 0x010e, 0x0104, 0x8101,

        0x8303, 0x0306, 0x030c, 0x8309, 0x0318, 0x831d, 0x8317, 0x0312,
        0x0330, 0x8335, 0x833f, 0x033a, 0x832b, 0x032e, 0x0324, 0x8321,
        0x0360, 0x8365, 0x836f, 0x036a, 0x837b, 0x037e, 0x0374, 0x8371,
        0x8353, 0x0356, 0x035c, 0x8359, 0x0348, 0x834d, 0x8347, 0x0342,
        0x03c0, 0x83c5, 0x83cf, 0x03ca, 0x83db, 0x03de, 0x03d4, 0x83d1,
        0x83f3, 0x03f6, 0x03fc, 0x83f9, 0x03e8, 0x83ed, 0x83e7, 0x03e2,
        0x83a3, 0x03a6, 0x03ac, 0x83a9, 0x03b8, 0x83bd, 0x83b7, 0x03b2,
        0x0390, 0x8395, 0x839f, 0x039a, 0x838b, 0x038e, 0x0384, 0x8381,

        0x0280, 0x8285, 0x828f, 0x028a, 0x829b, 0x029e, 0x0294, 0x8291,
        0x82b3, 0x02b6, 0x02bc, 0x82b9, 0x02a8, 0x82ad, 0x82a7, 0x02a2,
        0x82e3, 0x02e6, 0x02ec, 0x82e9, 0x02f8, 0x82fd, 0x82f7, 0x02f2,
        0x02d0, 0x82d5, 0x82df, 0x02da, 0x82cb, 0x02ce, 0x02c4, 0x82c1,
        0x8243, 0x0246, 0x024c, 0x8249, 0x0258, 0x825d, 0x8257, 0x0252,
        0x0270, 0x8275, 0x827f, 0x027a, 0x826b, 0x026e, 0x0264, 0x8261,
        0x0220, 0x8225, 0x822f, 0x022a, 0x823b, 0x023e, 0x0234, 0x8231,
        0x8213, 0x0216, 0x021c, 0x8219, 0x0208, 0x820d, 0x8207, 0x0202
};

/*
 * This is the lookup table for computing the CRC-check word.
 * As described in section 2.4.3.1 and depicted in Figure A.9
 * of ISO/IEC 11172-3, the generator polynomial is:
 *
 * G(X) = X^8 + X^4 + X^3 + x^2 + 1
 */
# define CRC_POLY2  0x1d

/*
 * G(X) = X^16 + X^12 + X^5 + 1
 */
# define CRC_POLY3 0x1021

const unsigned short crc_table3[256] = {
        0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
        0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
        0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
        0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
        0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
        0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
        0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
        0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
        0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
        0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
        0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
        0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
        0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
        0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
        0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
        0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
        0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
        0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
        0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
        0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
        0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
        0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
        0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
        0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
        0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
        0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
        0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
        0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
        0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
        0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
        0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
        0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0,
};

const unsigned int Bit_allocation[3][32][16] =
        {
                {
                        {0, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535},
                        {0, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535},
                        {0, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535},
                        {0, 3, 5, 7, 9,  15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 65535},
                        {0, 3, 5, 7, 9,  15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 65535},
                        {0, 3, 5, 7, 9,  15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 65535},
                        {0, 3, 5, 7, 9,  15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 65535},
                        {0, 3, 5, 7, 9,  15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 65535},
                        {0, 3, 5, 7, 9,  15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 65535},
                        {0, 3, 5, 7, 9,  15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 65535},
                        {0, 3, 5, 7, 9,  15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 65535},
                        {0, 3, 5, 7, 9, 15, 31, 65535},
                        {0, 3, 5, 7, 9, 15, 31, 65535},
                        {0, 3, 5, 7, 9, 15, 31, 65535},
                        {0, 3, 5, 7, 9, 15, 31, 65535},
                        {0, 3, 5, 7, 9, 15, 31, 65535},
                        {0, 3, 5, 7, 9, 15, 31, 65535},
                        {0, 3, 5, 7, 9, 15, 31, 65535},
                        {0, 3, 5, 7, 9, 15, 31, 65535},
                        {0, 3, 5, 7, 9, 15, 31, 65535},
                        {0, 3, 5, 7, 9, 15, 31, 65535},
                        {0, 3, 5, 7, 9, 15, 31, 65535},
                        {0, 3, 5, 7, 9, 15, 31, 65535},
                        {0, 3, 5, 65535},
                        {0, 3, 5, 65535},
                        {0, 3, 5, 65535},
                        {0, 3, 5, 65535},
                },
                {
                        {0, 3, 5, 9,  15, 31, 63,  127, 255, 511,  1023, 2047, 4095, 8191,  16383, 32767},
                        {0, 3, 5, 9,  15, 31, 63,  127, 255, 511,  1023, 2047, 4095, 8191,  16383, 32767},
                        {0, 3, 5, 9,  15, 31, 63,  127},
                        {0, 3, 5, 9, 15, 31, 63, 127},
                        {0, 3, 5, 9, 15, 31, 63, 127},
                        {0, 3, 5, 9, 15, 31, 63, 127},
                        {0, 3, 5, 9, 15, 31, 63, 127},
                        {0, 3, 5, 9, 15, 31, 63, 127},
                },
                {
                        {0, 3, 5, 7,  9,  15, 31,  63,  127, 255,  511,  1023, 2047, 4095,  8191,  16383},
                        {0, 3, 5, 7,  9,  15, 31,  63,  127, 255,  511,  1023, 2047, 4095,  8191,  16383},
                        {0, 3, 5, 7,  9,  15, 31,  63,  127, 255,  511,  1023, 2047, 4095,  8191,  16383},
                        {0, 3, 5, 7, 9,  15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383},
                        {0, 3, 5, 9, 15, 31, 63, 127},
                        {0, 3, 5, 9, 15, 31, 63, 127},
                        {0, 3, 5, 9, 15, 31, 63, 127},
                        {0, 3, 5, 9, 15, 31, 63, 127},
                        {0, 3, 5, 9, 15, 31, 63, 127},
                        {0, 3, 5, 9, 15, 31, 63, 127},
                        {0, 3, 5, 9, 15, 31, 63, 127},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                        {0, 3, 5, 9},
                }
        };

const unsigned int C_table[17] =
        {357913941, 429496729, 306783378, 477218588, 286331153, 277094664, 272696336, 270549121,
         269488144, 268960770, 268697856, 268566592, 268501008, 268468228, 268451840, 268443648,
         268439552};

const unsigned int D_table[17] =
        {134217728, 134217728, 67108864, 134217728, 33554432, 16777216, 8388608, 4194304, 2097152,
         1048576, 524288, 262144, 131072, 65536, 32767, 16384, 8192};

const unsigned int Scale_table[64] =
        {
                536870912, 426114725, 338207481, 268435456, 213057362, 169103740, 134217728,
                106528681,
                84551870, 67108864, 53264340, 42275935, 33554432, 26632170, 21137967, 16777216,
                13316085, 10568983, 8388608, 6658042, 5284491, 4194304, 3329021, 2642245,
                2097152, 1664510, 1321122, 1048576, 832255, 660561, 524288, 416127,
                330280, 262144, 208063, 165140, 131072, 104031, 82570, 65536,
                52015, 41285, 32768, 26007, 20642, 16384, 13003, 10321,
                8192, 6501, 5160, 4095, 3250, 2580, 2047, 1625,
                1290, 1024, 812, 645, 511, 406, 322, 0
        };

const int Di_coeff[512] =
        {
                0, -4096, -4096, -4096, -4096, -4096, -4096, -8192, -8192, -8192, -8192, -12287,
                -12287, -16383, -16383, -20480,
                -20480, -24576, -28672, -28672, -32767, -36863, -40960, -45056, -53247, -57343,
                -65536, -69631, -77824, -86016, -98304, -106496,
                -118784, -126975, -143360, -155648, -167935, -184320, -200704, -217088, -237568,
                -258048, -278528, -299008, -323583, -348159, -372736, -397312,
                -425983, -454656, -479231, -512000, -540671, -569344, -602112, -630784, -659455,
                -692223, -720896, -749567, -778240, -802816, -827391, -851967,
                872447, 892927, 909311, 921600, 929791, 933888, 933888, 929791, 917504, 905215,
                880640, 851967, 819200, 774143, 724992, 667648,
                598015, 520191, 434176, 339967, 233472, 118784, -8192, -147455, -294912, -454656,
                -626688, -806911, -999424, -1204224, -1421312, -1642495,
                -1880063, -2125824, -2379775, -2641920, -2912255, -3190784, -3473407, -3764223,
                -4059136, -4358144, -4657151, -4956160, -5255167, -5554176, -5849088, -6135807,
                -6418431, -6692863, -6955008, -7204864, -7442432, -7659520, -7860223, -8036351,
                -8196096, -8323071, -8425471, -8499199, -8540159, -8548352, -8519679, -8450048,
                8343551, 8191999, 7995391, 7753728, 7462912, 7122943, 6733823, 6287359, 5791744,
                5242880, 4632575, 3973119, 3252224, 2478079, 1646591, 757760,
                -184320, -1179647, -2232319, -3334143, -4485119, -5685247, -6930431, -8216576,
                -9543680, -10907647, -12304383, -13725695, -15175679, -16642048, -18124800,
                -19611647,
                -21106687, -22597631, -24080384, -25546751, -26988543, -28405759, -29782015,
                -31117312, -32399359, -33624063, -34779136, -35860479, -36855808, -37761023,
                -38567936, -39260159,
                -39841791, -40296448, -40615935, -40792063, -40820736, -40693759, -40398848,
                -39935999, -39288832, -38457344, -37433343, -36208639, -34783232, -33144831,
                -31293439, -29220863,
                26927103, 24408063, 21659648, 18681856, 15466495, 12021760, 8343551, 4431872,
                286719, -4087807, -8691711, -13516800, -18567168, -23830528, -29302784, -34979840,
                -40857600, -46919680, -53166079, -59588607, -66170879, -72904704, -79781887,
                -86790143, -93917183, -101146623, -108470272, -115871744, -123338751, -130854911,
                -138407935, -145981439,
                -153554943, -161120256, -168656895, -176152575, -183586816, -190943232, -198205440,
                -205361151, -212389887, -219275264, -226009088, -232562687, -238931967, -245096448,
                -251039744, -256753664,
                -262221824, -267427840, -272359424, -277008384, -281362431, -285405183, -289136640,
                -292536320, -295604224, -298332159, -300707839, -302727167, -304386048, -305684480,
                -306610175, -307167231,
                307355648, 307167231, 306610175, 305684480, 304386048, 302727167, 300707839,
                298332159, 295604224, 292536320, 289136640, 285405183, 281362431, 277008384,
                272359424, 267427840,
                262221824, 256753664, 251039744, 245096448, 238931967, 232562687, 226009088,
                219275264, 212389887, 205361151, 198205440, 190943232, 183586816, 176152575,
                168656895, 161120256,
                153554943, 145981439, 138407935, 130854911, 123338751, 115871744, 108470272,
                101146623, 93917183, 86790143, 79781887, 72904704, 66170879, 59588607, 53166079,
                46919680,
                40857600, 34979840, 29302784, 23830528, 18567168, 13516800, 8691711, 4087807,
                -286719, -4431872, -8343551, -12021760, -15466495, -18681856, -21659648, -24408063,
                26927103, 29220863, 31293439, 33144831, 34783232, 36208639, 37433343, 38457344,
                39288832, 39935999, 40398848, 40693759, 40820736, 40792063, 40615935, 40296448,
                39841791, 39260159, 38567936, 37761023, 36855808, 35860479, 34779136, 33624063,
                32399359, 31117312, 29782015, 28405759, 26988543, 25546751, 24080384, 22597631,
                21106687, 19611647, 18124800, 16642048, 15175679, 13725695, 12304383, 10907647,
                9543680, 8216576, 6930431, 5685247, 4485119, 3334143, 2232319, 1179647,
                184320, -757760, -1646591, -2478079, -3252224, -3973119, -4632575, -5242880,
                -5791744, -6287359, -6733823, -7122943, -7462912, -7753728, -7995391, -8191999,
                8343551, 8450048, 8519679, 8548352, 8540159, 8499199, 8425471, 8323071, 8196096,
                8036351, 7860223, 7659520, 7442432, 7204864, 6955008, 6692863,
                6418431, 6135807, 5849088, 5554176, 5255167, 4956160, 4657151, 4358144, 4059136,
                3764223, 3473407, 3190784, 2912255, 2641920, 2379775, 2125824,
                1880063, 1642495, 1421312, 1204224, 999424, 806911, 626688, 454656, 294912, 147455,
                8192, -118784, -233472, -339967, -434176, -520191,
                -598015, -667648, -724992, -774143, -819200, -851967, -880640, -905215, -917504,
                -929791, -933888, -933888, -929791, -921600, -909311, -892927,
                872447, 851967, 827391, 802816, 778240, 749567, 720896, 692223, 659455, 630784,
                602112, 569344, 540671, 512000, 479231, 454656,
                425983, 397312, 372736, 348159, 323583, 299008, 278528, 258048, 237568, 217088,
                200704, 184320, 167935, 155648, 143360, 126975,
                118784, 106496, 98304, 86016, 77824, 69631, 65536, 57343, 53247, 45056, 40960,
                36863, 32767, 28672, 28672, 24576,
                20480, 20480, 16383, 16383, 12287, 12287, 8192, 8192, 8192, 8192, 4096, 4096, 4096,
                4096, 4096, 4096
        };

const int N_coeff[33][32] =
        {
                {0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0,          0},
                {-13171503,  39387661,   -65224495,  90433181,   -114770946, 138003404,  -159906814, 180270234,  -198897553, 215609379,  -230244770, 242662778,  -252743810, 260390781,  -265530047, 268112113,  -268112113, 265530047,  -260390781, 252743810,  -242662778, 230244770,  -215609379, 198897553,  -180270234, 159906814,  -138003404, 114770946,  -90433181,  65224495,   -39387661,  13171503},
                {-26311275,  77922699,   -126539598, 170293650,  -207503413, 236738936,  -256876715, 267142865,  -267142865, 256876715,  -236738936, 207503413,  -170293650, 126539598,  -77922699,  26311275,   26311275,   -77922699,  126539598,  -170293650, 207503413,  -236738936, 256876715,  -267142865, 267142865,  -256876715, 236738936,  -207503413, 170293650,  -126539598, 77922699,   -26311275},
                {-39387661,  114770946,  -180270234, 230244770,  -260390781, 268112113,  -252743810, 215609379,  -159906814, 90433181,   -13171503,  -65224495,  138003404,  -198897553, 242662778,  -265530047, 265530047,  -242662778, 198897553,  -138003404, 65224495,   13171503,   -90433181,  159906814,  -215609379, 252743810,  -268112113, 260390781,  -230244770, 180270234,  -114770946, 39387661},
                {-52369159,  149134748,  -223195924, 263277543,  -263277543, 223195924,  -149134748, 52369159,   52369159,   -149134748, 223195924,  -263277543, 263277543,  -223195924, 149134748,  -52369159,  -52369159,  149134748,  -223195924, 263277543,  -263277543, 223195924,  -149134748, 52369159,   52369159,   -149134748, 223195924,  -263277543, 263277543,  -223195924, 149134748,  -52369159},
                {-65224495,  180270234,  -252743810, 265530047,  -215609379, 114770946,  13171503,   -138003404, 230244770,  -268112113, 242662778,  -159906814, 39387661,   90433181,   -198897553, 260390781,  -260390781, 198897553,  -90433181,  -39387661,  159906814,  -242662778, 268112113,  -230244770, 138003404,  -13171503,  -114770946, 215609379,  -265530047, 252743810,  -180270234, 65224495},
                {-77922699,  207503413,  -267142865, 236738936,  -126539598, -26311275,  170293650,  -256876715, 256876715,  -170293650, 26311275,   126539598,  -236738936, 267142865,  -207503413, 77922699,   77922699,   -207503413, 267142865,  -236738936, 126539598,  26311275,   -170293650, 256876715,  -256876715, 170293650,  -26311275,  -126539598, 236738936,  -267142865, 207503413,  -77922699},
                {-90433181,  230244770,  -265530047, 180270234,  -13171503,  -159906814, 260390781,  -242662778, 114770946,  65224495,   -215609379, 268112113,  -198897553, 39387661,   138003404,  -252743810, 252743810,  -138003404, -39387661,  198897553,  -268112113, 215609379,  -65224495,  -114770946, 242662778,  -260390781, 159906814,  13171503,   -180270234, 265530047,  -230244770, 90433181},
                {-102725801, 248002023,  -248002023, 102725801,  102725801,  -248002023, 248002023,  -102725801, -102725801, 248002023,  -248002023, 102725801,  102725801,  -248002023, 248002023,  -102725801, -102725801, 248002023,  -248002023, 102725801,  102725801,  -248002023, 248002023,  -102725801, -102725801, 248002023,  -248002023, 102725801,  102725801,  -248002023, 248002023,  -102725801},
                {-114770946, 260390781,  -215609379, 13171503,   198897553,  -265530047, 138003404,  90433181,   -252743810, 230244770,  -39387661,  -180270234, 268112113,  -159906814, -65224495,  242662778,  -242662778, 65224495,   159906814,  -268112113, 180270234,  39387661,   -230244770, 252743810,  -90433181,  -138003404, 265530047,  -198897553, -13171503,  215609379,  -260390781, 114770946},
                {-126539598, 267142865,  -170293650, -77922699,  256876715,  -207503413, -26311275,  236738936,  -236738936, 26311275,   207503413,  -256876715, 77922699,   170293650,  -267142865, 126539598,  126539598,  -267142865, 170293650,  77922699,   -256876715, 207503413,  26311275,   -236738936, 236738936,  -26311275,  -207503413, 256876715,  -77922699,  -170293650, 267142865,  -126539598},
                {-138003404, 268112113,  -114770946, -159906814, 265530047,  -90433181,  -180270234, 260390781,  -65224495,  -198897553, 252743810,  -39387661,  -215609379, 242662778,  -13171503,  -230244770, 230244770,  13171503,   -242662778, 215609379,  39387661,   -252743810, 198897553,  65224495,   -260390781, 180270234,  90433181,   -265530047, 159906814,  114770946,  -268112113, 138003404},
                {-149134748, 263277543,  -52369159,  -223195924, 223195924,  52369159,   -263277543, 149134748,  149134748,  -263277543, 52369159,   223195924,  -223195924, -52369159,  263277543,  -149134748, -149134748, 263277543,  -52369159,  -223195924, 223195924,  52369159,   -263277543, 149134748,  149134748,  -263277543, 52369159,   223195924,  -223195924, -52369159,  263277543,  -149134748},
                {-159906814, 252743810,  13171503,   -260390781, 138003404,  180270234,  -242662778, -39387661,  265530047,  -114770946, -198897553, 230244770,  65224495,   -268112113, 90433181,   215609379,  -215609379, -90433181,  268112113,  -65224495,  -230244770, 198897553,  114770946,  -265530047, 39387661,   242662778,  -180270234, -138003404, 260390781,  -13171503,  -252743810, 159906814},
                {-170293650, 236738936,  77922699,   -267142865, 26311275,   256876715,  -126539598, -207503413, 207503413,  126539598,  -256876715, -26311275,  267142865,  -77922699,  -236738936, 170293650,  170293650,  -236738936, -77922699,  267142865,  -26311275,  -256876715, 126539598,  207503413,  -207503413, -126539598, 256876715,  26311275,   -267142865, 77922699,   236738936,  -170293650},
                {-180270234, 215609379,  138003404,  -242662778, -90433181,  260390781,  39387661,   -268112113, 13171503,   265530047,  -65224495,  -252743810, 114770946,  230244770,  -159906814, -198897553, 198897553,  159906814,  -230244770, -114770946, 252743810,  65224495,   -265530047, -13171503,  268112113,  -39387661,  -260390781, 90433181,   242662778,  -138003404, -215609379, 180270234},
                {-189812531, 189812531,  189812531,  -189812531, -189812531, 189812531,  189812531,  -189812531, -189812531, 189812531,  189812531,  -189812531, -189812531, 189812531,  189812531,  -189812531, -189812531, 189812531,  189812531,  -189812531, -189812531, 189812531,  189812531,  -189812531, -189812531, 189812531,  189812531,  -189812531, -189812531, 189812531,  189812531,  -189812531},
                {-198897553, 159906814,  230244770,  -114770946, -252743810, 65224495,   265530047,  -13171503,  -268112113, -39387661,  260390781,  90433181,   -242662778, -138003404, 215609379,  180270234,  -180270234, -215609379, 138003404,  242662778,  -90433181,  -260390781, 39387661,   268112113,  13171503,   -265530047, -65224495,  252743810,  114770946,  -230244770, -159906814, 198897553},
                {-207503413, 126539598,  256876715,  -26311275,  -267142865, -77922699,  236738936,  170293650,  -170293650, -236738936, 77922699,   267142865,  26311275,   -256876715, -126539598, 207503413,  207503413,  -126539598, -256876715, 26311275,   267142865,  77922699,   -236738936, -170293650, 170293650,  236738936,  -77922699,  -267142865, -26311275,  256876715,  126539598,  -207503413},
                {-215609379, 90433181,   268112113,  65224495,   -230244770, -198897553, 114770946,  265530047,  39387661,   -242662778, -180270234, 138003404,  260390781,  13171503,   -252743810, -159906814, 159906814,  252743810,  -13171503,  -260390781, -138003404, 180270234,  242662778,  -39387661,  -265530047, -114770946, 198897553,  230244770,  -65224495,  -268112113, -90433181,  215609379},
                {-223195924, 52369159,   263277543,  149134748,  -149134748, -263277543, -52369159,  223195924,  223195924,  -52369159,  -263277543, -149134748, 149134748,  263277543,  52369159,   -223195924, -223195924, 52369159,   263277543,  149134748,  -149134748, -263277543, -52369159,  223195924,  223195924,  -52369159,  -263277543, -149134748, 149134748,  263277543,  52369159,   -223195924},
                {-230244770, 13171503,   242662778,  215609379,  -39387661,  -252743810, -198897553, 65224495,   260390781,  180270234,  -90433181,  -265530047, -159906814, 114770946,  268112113,  138003404,  -138003404, -268112113, -114770946, 159906814,  265530047,  90433181,   -180270234, -260390781, -65224495,  198897553,  252743810,  39387661,   -215609379, -242662778, -13171503,  230244770},
                {-236738936, -26311275,  207503413,  256876715,  77922699,   -170293650, -267142865, -126539598, 126539598,  267142865,  170293650,  -77922699,  -256876715, -207503413, 26311275,   236738936,  236738936,  26311275,   -207503413, -256876715, -77922699,  170293650,  267142865,  126539598,  -126539598, -267142865, -170293650, 77922699,   256876715,  207503413,  -26311275,  -236738936},
                {-242662778, -65224495,  159906814,  268112113,  180270234,  -39387661,  -230244770, -252743810, -90433181,  138003404,  265530047,  198897553,  -13171503,  -215609379, -260390781, -114770946, 114770946,  260390781,  215609379,  13171503,   -198897553, -265530047, -138003404, 90433181,   252743810,  230244770,  39387661,   -180270234, -268112113, -159906814, 65224495,   242662778},
                {-248002023, -102725801, 102725801,  248002023,  248002023,  102725801,  -102725801, -248002023, -248002023, -102725801, 102725801,  248002023,  248002023,  102725801,  -102725801, -248002023, -248002023, -102725801, 102725801,  248002023,  248002023,  102725801,  -102725801, -248002023, -248002023, -102725801, 102725801,  248002023,  248002023,  102725801,  -102725801, -248002023},
                {-252743810, -138003404, 39387661,   198897553,  268112113,  215609379,  65224495,   -114770946, -242662778, -260390781, -159906814, 13171503,   180270234,  265530047,  230244770,  90433181,   -90433181,  -230244770, -265530047, -180270234, -13171503,  159906814,  260390781,  242662778,  114770946,  -65224495,  -215609379, -268112113, -198897553, -39387661,  138003404,  252743810},
                {-256876715, -170293650, -26311275,  126539598,  236738936,  267142865,  207503413,  77922699,   -77922699,  -207503413, -267142865, -236738936, -126539598, 26311275,   170293650,  256876715,  256876715,  170293650,  26311275,   -126539598, -236738936, -267142865, -207503413, -77922699,  77922699,   207503413,  267142865,  236738936,  126539598,  -26311275,  -170293650, -256876715},
                {-260390781, -198897553, -90433181,  39387661,   159906814,  242662778,  268112113,  230244770,  138003404,  13171503,   -114770946, -215609379, -265530047, -252743810, -180270234, -65224495,  65224495,   180270234,  252743810,  265530047,  215609379,  114770946,  -13171503,  -138003404, -230244770, -268112113, -242662778, -159906814, -39387661,  90433181,   198897553,  260390781},
                {-263277543, -223195924, -149134748, -52369159,  52369159,   149134748,  223195924,  263277543,  263277543,  223195924,  149134748,  52369159,   -52369159,  -149134748, -223195924, -263277543, -263277543, -223195924, -149134748, -52369159,  52369159,   149134748,  223195924,  263277543,  263277543,  223195924,  149134748,  52369159,   -52369159,  -149134748, -223195924, -263277543},
                {-265530047, -242662778, -198897553, -138003404, -65224495,  13171503,   90433181,   159906814,  215609379,  252743810,  268112113,  260390781,  230244770,  180270234,  114770946,  39387661,   -39387661,  -114770946, -180270234, -230244770, -260390781, -268112113, -252743810, -215609379, -159906814, -90433181,  -13171503,  65224495,   138003404,  198897553,  242662778,  265530047},
                {-267142865, -256876715, -236738936, -207503413, -170293650, -126539598, -77922699,  -26311275,  26311275,   77922699,   126539598,  170293650,  207503413,  236738936,  256876715,  267142865,  267142865,  256876715,  236738936,  207503413,  170293650,  126539598,  77922699,   26311275,   -26311275,  -77922699,  -126539598, -170293650, -207503413, -236738936, -256876715, -267142865},
                {-268112113, -265530047, -260390781, -252743810, -242662778, -230244770, -215609379, -198897553, -180270234, -159906814, -138003404, -114770946, -90433181,  -65224495,  -39387661,  -13171503,  13171503,   39387661,   65224495,   90433181,   114770946,  138003404,  159906814,  180270234,  198897553,  215609379,  230244770,  242662778,  252743810,  260390781,  265530047,  268112113},
                {-268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456, -268435456},
        };

void audio_buf_init(unsigned char *Audio_Frame, unsigned int Frame_Length) {
    audio_frame = Audio_Frame;
    stream.pos = 0;
    stream.num = Frame_Length;
    stream.data = 0;
    stream.bits = 0;
}

void drop_bits(register unsigned int num) {
    register unsigned int bits;
    register unsigned int temp;

    bits = stream.bits;
    if (bits >= num) {
        stream.data = stream.data << num;
        stream.bits = bits - num;
        return;
    }

    temp = stream.pos;
    do {
        bits += 8;
        temp++;
    } while (bits < num);

    if (temp <= stream.num) {
        stream.pos = temp;
        bits -= num;
        stream.data = audio_frame[temp - 1] << (32 - bits);
        stream.bits = bits;
        return;
    }

    stream.pos = stream.num;
    stream.data = 0;
    stream.bits = 0;
}

unsigned int read_bits(unsigned int num) {
    unsigned int data;
    unsigned int bits;
    unsigned int temp;

    if (!num)
        return num;

    data = stream.data;
    bits = stream.bits;

    if (bits < num) {
        temp = stream.pos;
        while ((bits <= 24) && (temp < stream.num)) {
            data += (audio_frame[temp] << (24 - bits));
            bits += 8;
            temp++;
        }
        stream.pos = temp;
    }

    if (bits >= num) {
        temp = data >> (32 - num);
        stream.data = (data << num);
        stream.bits = (bits - num);
        return temp;
    }

    stream.data = 0;
    stream.bits = 0;
    return 0;
}

void CRC_buf_init(unsigned char *Audio_Frame, unsigned int Frame_Length) {
    CRC_frame = Audio_Frame;
    CRC_stream.pos = 0;
    CRC_stream.num = Frame_Length;
    CRC_stream.data = 0;
    CRC_stream.bits = 0;
}

void CRC_drop_bits(register unsigned int num) {
    register unsigned int bits;
    register unsigned int temp;

    bits = CRC_stream.bits;
    if (bits >= num) {
        CRC_stream.data = CRC_stream.data << num;
        CRC_stream.bits = bits - num;
        return;
    }

    temp = CRC_stream.pos;
    do {
        bits += 8;
        temp++;
    } while (bits < num);

    if (temp <= CRC_stream.num) {
        CRC_stream.pos = temp;
        bits -= num;
        CRC_stream.data = CRC_frame[temp - 1] << (32 - bits);
        CRC_stream.bits = bits;
        return;
    }

    CRC_stream.pos = CRC_stream.num;
    CRC_stream.data = 0;
    CRC_stream.bits = 0;
}

unsigned int CRC_read_bits(unsigned int num) {
    unsigned int data;
    unsigned int bits;
    unsigned int temp;

    if (!num)
        return num;

    data = CRC_stream.data;
    bits = CRC_stream.bits;

    if (bits < num) {
        temp = CRC_stream.pos;
        while ((bits <= 24) && (temp < CRC_stream.num)) {
            data += (CRC_frame[temp] << (24 - bits));
            bits += 8;
            temp++;
        }
        CRC_stream.pos = temp;
    }

    if (bits >= num) {
        temp = data >> (32 - num);
        CRC_stream.data = (data << num);
        CRC_stream.bits = (bits - num);
        return temp;
    }

    CRC_stream.data = 0;
    CRC_stream.bits = 0;
    return 0;
}


int head_decode(void) {
    drop_bits(12);
    audio_header.ID = read_bits(1);
    audio_header.layer = read_bits(2);
    audio_header.protection = read_bits(1);
    audio_header.bitrate_index = read_bits(4);
    audio_header.sampling_freq = read_bits(2);
    drop_bits(2);
    audio_header.mode = read_bits(2);
    audio_header.mode_extension = read_bits(2);
    audio_header.copyright = read_bits(1);
    audio_header.original_copy = read_bits(1);
    audio_header.emphasis = read_bits(2);
    return 1;
}

int get_parameters(int *nch, int *sampling, int *bound, int *sblimit, int *table_id) {

    if (audio_header.layer != 2)
        return 0;

    if (audio_header.sampling_freq != 1)
        return 0;

    if (audio_header.ID == 0) {
        *sampling = 24000;
        *nch = 2;
        *table_id = 2;
        *bound = 30;
        *sblimit = 30;
        if (audio_header.mode == 1) {
            *bound = 4 + audio_header.mode_extension * 4;
        }

        if (audio_header.mode == 3) {
            *nch = 1;
        }
    } else {
        *sampling = 48000;
        *nch = 2;
        *bound = 27;
        if (audio_header.mode == 1) {
            *bound = 4 + audio_header.mode_extension * 4;
        }

        if (audio_header.mode == 3) {
            *nch = 1;
            if (audio_header.bitrate_index <= 2) {
                *table_id = 1;
                *sblimit = 8;
            } else {
                *table_id = 0;
                *sblimit = 27;
            }
        } else {
            *nch = 2;
            if (audio_header.bitrate_index <= 6) {
                *table_id = 1;
                *sblimit = 8;
            } else {
                *table_id = 0;
                *sblimit = 27;
            }
        }
    }
    if (*bound > *sblimit)
        *bound = *sblimit;

    return 1;
}

unsigned int get_CRC_word(int n) {
    return sCRC_words.crc_word[4 - n];

}

int CRC_check(unsigned int n, unsigned int CRC_bits) {
    unsigned int CRC_word;
    register unsigned int crc;
    unsigned int len;
    unsigned int poly;
    unsigned int data;
    unsigned int msb;
    int i;

    if (n == 0) {
        poly = CRC_POLY1;
        CRC_read_bits(16);
        crc = 0xffff;
//		register unsigned long data;

        data = CRC_read_bits(16);

        crc = (crc << 8) ^ crc_table1[((crc >> 8) ^ (data >> 8)) & 0xff];
        crc = (crc << 8) ^ crc_table1[((crc >> 8) ^ (data >> 0)) & 0xff];

        CRC_word = CRC_read_bits(16);


        for (len = CRC_bits; len >= 16; len -= 16) {
//			register unsigned long data;

            data = CRC_read_bits(16);

            crc = (crc << 8) ^ crc_table1[((crc >> 8) ^ (data >> 8)) & 0xff];
            crc = (crc << 8) ^ crc_table1[((crc >> 8) ^ (data >> 0)) & 0xff];
        }

        switch (len / 8) {
            case 1:
                crc = (crc << 8) ^
                      crc_table1[((crc >> 8) ^ CRC_read_bits(8)) & 0xff];

                len %= 8;

            case 0:
                break;
        }

        while (len--) {
//			register unsigned int msb;

            msb = CRC_read_bits(1) ^ (crc >> 15);

            crc <<= 1;
            if (msb & 1)
                crc ^= poly;
        }

        crc = crc & 0xffff;
    } else {
        if (sCRC_words.flag == 0)
            return 1;
        poly = CRC_POLY2;
        crc = 0;
        CRC_word = get_CRC_word(n);

        for (len = CRC_bits; len > 0; len -= 6) {
            data = CRC_read_bits(6);

            for (i = 5; i > 2; i--) {
                msb = (data >> i) ^ (crc >> 7);

                crc <<= 1;
                if (msb & 1)
                    crc ^= poly;
            }
        }

        crc = crc & 0xff;
    }

    if (crc == CRC_word)
        return 1;
    else
        return 0;
}

unsigned int get_bits(unsigned int value) {
    unsigned int cnt = 0;
    int i;
    for (i = 0; i < 16; i++)
        cnt += (value >> i) & 0x01;
    return cnt;

}

int get_c_d(int *C, int *D, unsigned int value) {
    unsigned int bits;
    if (value == 3) {
        *C = C_table[0];
        *D = D_table[0];
    } else if (value == 5) {
        *C = C_table[1];
        *D = D_table[1];
    } else if (value == 7) {
        *C = C_table[2];
        *D = D_table[2];
    } else if (value == 9) {
        *C = C_table[3];
        *D = D_table[3];
    } else {
        bits = get_bits(value);
        if (bits > 16)
            return 0;
        *C = C_table[bits];
        *D = D_table[bits];
    }
    return 1;
}

int audio_data_decode(int nch, int *sampling, int *PCM_Length, int bound, int sblimit, int table_id,
                      short *PCM_Frame) {
    int ch;
    int sb;
    int gr;
    int s;
    unsigned int bits;
    unsigned int value;
    unsigned int sample_code;
    int sample_temp[3];
    int temp;
    unsigned int Allocation[2][32] = {0};
    unsigned int Scfsi[2][32] = {0};
    unsigned int ScaleFactor[2][32][3] = {0};
    int Sample[2][32][36] = {0};
    int C;
    int D;
    static int V[2][1024] = {0};
    int U[2][512] = {0};

    unsigned int CRC_bits[5] = {0};
    int i;
    int CRC_N;
    int flag[4] = {0};


    for (sb = 0; sb < bound; sb++) {
        for (ch = 0; ch < nch; ch++) {
            Allocation[ch][sb] = read_bits(Nbal[table_id][sb]);
            CRC_bits[0] += Nbal[table_id][sb];
        }
    }
    for (sb = bound; sb < sblimit; sb++) {
        Allocation[0][sb] = Allocation[1][sb] = read_bits(Nbal[table_id][sb]);
        CRC_bits[0] += Nbal[table_id][sb];
    }

    for (sb = 0; sb < sblimit; sb++) {
        for (ch = 0; ch < nch; ch++) {
            if (Allocation[ch][sb] != 0) {
                Scfsi[ch][sb] = read_bits(2);
                CRC_bits[0] += 2;
            }
        }
    }

    if (CRC_check(0, CRC_bits[0])) {
        sN_ch = nch;
        sSampling = *sampling;
        sPCM_Length = 1152 * nch;
        *PCM_Length = 1152 * nch;
    } else {
        nch = sN_ch;
        *sampling = sSampling;
        *PCM_Length = sPCM_Length;
        memcpy(PCM_Frame, sPCM_Frame, *PCM_Length * 2);
        memset(sPCM_Frame, 0, sizeof(sPCM_Frame));
        return 1;
    }


    for (sb = 0; sb < sblimit; sb++) {
        for (ch = 0; ch < nch; ch++) {
            if (Allocation[ch][sb] != 0) {
                if (Scfsi[ch][sb] == 0) {
                    ScaleFactor[ch][sb][0] = read_bits(6);
                    ScaleFactor[ch][sb][1] = read_bits(6);
                    ScaleFactor[ch][sb][2] = read_bits(6);

                    if (sb < 4) {
                        CRC_bits[1] += 18;
                    } else if (sb < 8) {
                        CRC_bits[2] += 18;
                    } else if (sb < 16) {
                        CRC_bits[3] += 18;
                    } else {
                        CRC_bits[4] += 18;
                    }
                } else if (Scfsi[ch][sb] == 1) {
                    ScaleFactor[ch][sb][0] =
                    ScaleFactor[ch][sb][1] = read_bits(6);
                    ScaleFactor[ch][sb][2] = read_bits(6);

                    if (sb < 4) {
                        CRC_bits[1] += 12;
                    } else if (sb < 8) {
                        CRC_bits[2] += 12;
                    } else if (sb < 16) {
                        CRC_bits[3] += 12;
                    } else {
                        CRC_bits[4] += 12;
                    }
                } else if (Scfsi[ch][sb] == 2) {
                    ScaleFactor[ch][sb][0] =
                    ScaleFactor[ch][sb][1] =
                    ScaleFactor[ch][sb][2] = read_bits(6);

                    if (sb < 4) {
                        CRC_bits[1] += 6;
                    } else if (sb < 8) {
                        CRC_bits[2] += 6;
                    } else if (sb < 16) {
                        CRC_bits[3] += 6;
                    } else {
                        CRC_bits[4] += 6;
                    }
                } else {
                    ScaleFactor[ch][sb][0] = read_bits(6);
                    ScaleFactor[ch][sb][1] =
                    ScaleFactor[ch][sb][2] = read_bits(6);

                    if (sb < 4) {
                        CRC_bits[1] += 12;
                    } else if (sb < 8) {
                        CRC_bits[2] += 12;
                    } else if (sb < 16) {
                        CRC_bits[3] += 12;
                    } else {
                        CRC_bits[4] += 12;
                    }
                }

            }
        }
    }


    if (table_id == 1)
        CRC_N = 3;
    else
        CRC_N = 5;

    for (i = 1; i < CRC_N; i++) {
        if (CRC_check(i, CRC_bits[i])) {
            flag[i - 1] = 0;
        } else {
            flag[i - 1] = 1;
        }
    }

    if (flag[0] == 1) {
        for (ch = 0; ch < nch; ch++)
            for (sb = 0; sb < 4; sb++)
                for (gr = 0; gr < 3; gr++) {
                    ScaleFactor[ch][sb][gr] = 0x3f;//sScaleFactor[ch][sb][gr];
                }
    }


    if (flag[1] == 1) {
        for (ch = 0; ch < nch; ch++)
            for (sb = 4; sb < 8; sb++)
                for (gr = 0; gr < 3; gr++) {
                    ScaleFactor[ch][sb][gr] = 0x3f;//sScaleFactor[ch][sb][gr];
                }
    }

    if (flag[2] == 1) {
        for (ch = 0; ch < nch; ch++)
            for (sb = 8; sb < 16; sb++)
                for (gr = 0; gr < 3; gr++) {
                    ScaleFactor[ch][sb][gr] = 0x3f;//sScaleFactor[ch][sb][gr];
                }
    }

    if (flag[3] == 1) {
        for (ch = 0; ch < nch; ch++)
            for (sb = 16; sb < 32; sb++)
                for (gr = 0; gr < 3; gr++) {
                    ScaleFactor[ch][sb][gr] = 0x3f;//sScaleFactor[ch][sb][gr];
                }
    }


    for (gr = 0; gr < 12; gr++) {
        for (sb = 0; sb < bound; sb++) {
            for (ch = 0; ch < nch; ch++) {
                if (Allocation[ch][sb] != 0) {
                    value = Bit_allocation[table_id][sb][Allocation[ch][sb]];
                    if (value == 3) {
                        bits = 2;
                        sample_code = read_bits(5);
                        for (s = 0; s < 3; s++) {
                            sample_temp[s] = sample_code % 3;
                            sample_code /= 3;
                        }
                    } else if (value == 5) {
                        bits = 3;
                        sample_code = read_bits(7);
                        for (s = 0; s < 3; s++) {
                            sample_temp[s] = sample_code % 5;
                            sample_code /= 5;
                        }
                    } else if (value == 9) {
                        bits = 4;
                        sample_code = read_bits(10);
                        for (s = 0; s < 3; s++) {
                            sample_temp[s] = sample_code % 9;
                            sample_code /= 9;
                        }
                    } else {
                        bits = get_bits(value);
                        for (s = 0; s < 3; s++) {
                            sample_temp[s] = read_bits(bits);
                        }
                    }

                    for (s = 0; s < 3; s++) {
                        temp = sample_temp[s] ^ (1 << (bits - 1));
                        temp |= -(temp & (1 << (bits - 1)));
                        temp <<= FRACBITS - (bits - 1);
                        if (!get_c_d(&C, &D, value))
                            return 0;
                        Sample[ch][sb][gr * 3 + s] = MUL(temp + D, C);

                    }
                }
            }
        }
        for (sb = bound; sb < sblimit; sb++) {
            if (Allocation[0][sb] != 0) {
                value = Bit_allocation[table_id][sb][Allocation[0][sb]];
                if (value == 3) {
                    bits = 2;
                    sample_code = read_bits(5);
                    for (s = 0; s < 3; s++) {
                        sample_temp[s] = sample_code % 3;
                        sample_code /= 3;
                    }
                } else if (value == 5) {
                    bits = 3;
                    sample_code = read_bits(7);
                    for (s = 0; s < 3; s++) {
                        sample_temp[s] = sample_code % 5;
                        sample_code /= 5;
                    }
                } else if (value == 9) {
                    bits = 4;
                    sample_code = read_bits(10);
                    for (s = 0; s < 3; s++) {
                        sample_temp[s] = sample_code % 9;
                        sample_code /= 9;
                    }
                } else {
                    bits = get_bits(value);
                    for (s = 0; s < 3; s++) {
                        sample_temp[s] = read_bits(bits);
                    }
                }

                for (s = 0; s < 3; s++) {
                    temp = sample_temp[s] ^ (1 << (bits - 1));
                    temp |= -(temp & (1 << (bits - 1)));
                    temp <<= FRACBITS - (bits - 1);
                    if (!get_c_d(&C, &D, value))
                        return 0;
                    Sample[0][sb][gr * 3 + s] = MUL(temp + D, C);
                    if (nch == 2)
                        Sample[1][sb][gr * 3 + s] = Sample[0][sb][gr * 3 + s];
                }
            }
        }
    }

    for (ch = 0; ch < nch; ch++) {
        for (sb = 0; sb < 32; sb++) {
            for (gr = 0; gr < 36; gr++) {
                Sample[ch][sb][gr] =
                        MUL(Sample[ch][sb][gr], Scale_table[ScaleFactor[ch][sb][gr / 12]]);
            }
        }
    }

    for (ch = 0; ch < nch; ch++) {
        for (gr = 0; gr < 36; gr++) {
            for (s = 1024 - 1; s >= 64; s--)
                V[ch][s] = V[ch][s - 64];
            for (s = 16; s <= 48; s++) {
                temp = 0;
                for (sb = 0; sb < 32; sb++)
                    temp += MUL(Sample[ch][sb][gr], N_coeff[s - 16][sb]);

                V[ch][s] = temp;
            }
            for (s = 0; s < 16; s++)
                V[ch][s] = -V[ch][32 - s];
            for (s = 49; s < 64; s++)
                V[ch][s] = V[ch][96 - s];
            for (s = 0; s < 8; s++) {
                for (sb = 0; sb < 32; sb++) {
                    U[ch][64 * s + sb] = V[ch][128 * s + sb];
                    U[ch][64 * s + 32 + sb] = V[ch][128 * s + 96 + sb];
                }
            }

            for (s = 0; s < 512; s++) {
                U[ch][s] = MUL(U[ch][s], Di_coeff[s]);
            }
            for (sb = 0; sb < 32; sb++) {
                temp = 0;
                for (s = 0; s < 16; s++) {
                    temp += U[ch][sb + 32 * s];
                }

                temp += (1 << 12);
                if (temp > ((1 << 28) - 1))
                    temp = (1 << 28) - 1;
                if (temp < -(1 << 28))
                    temp = -(1 << 28);

                temp = (temp >> 13) & 0xffff;
                PCM_Frame[gr * 32 * nch + sb * nch + ch] = temp;
            }
        }
    }
    memcpy(sPCM_Frame, PCM_Frame, *PCM_Length * 2);
    return 1;
}

int Label_CRC_check(unsigned char *str, unsigned int len) {
    unsigned int data;
    unsigned int crc_word;
    unsigned int crc = 0xffff;
    unsigned int i;

    for (i = 0; i < len; i++) {
        data = str[i];
        crc = (crc << 8) ^ crc_table3[((crc >> 8) ^ data) & 0xff];
    }

    crc = crc & 0xffff;
    crc = crc ^ 0xffff;

    crc_word = (str[len] << 8) + str[len + 1];

    if (crc == crc_word)
        return 1;
    else
        return 0;
}

void LabelCheck(void) {
    unsigned int AppTy;
    unsigned int temp;
    unsigned int i;

    AppTy = text.Str[0] & 0x1f;

    if (AppTy != 2)
        return;

    memset(&d_label, 0, sizeof(d_label));

    temp = text.Str[1];
    d_label.Toggle = (temp >> 7) & 0x01;
    d_label.First_last = (temp >> 5) & 0x03;
    d_label.Cmd_flag = (temp >> 4) & 0x01;
    if (d_label.Cmd_flag)
        d_label.Cmd = temp & 0x0f;
    else
        d_label.Length = (temp & 0x0f) + 1;

    temp = text.Str[2];

    if (d_label.First_last & 2)
        d_label.Charset = (temp >> 4) & 0x0f;
    else
        d_label.SegNum = (temp >> 4) & 0x0f;

    if (!Label_CRC_check(&text.Str[1], d_label.Length + 2)) {
        memset(&Label, 0, sizeof(Label));
        store = 0;
        return;
    }

    if (d_label.Toggle != Toggle)
        change = 1;

    Toggle = d_label.Toggle;

    label_flag = 0;

    if (change) {
        if (d_label.First_last & 2) {
            memset(&Label, 0, sizeof(Label));
            store = 1;
        }

        if (store) {
            for (i = 0; i < d_label.Length; i++) {
                if (Label.num >= 256)
                    Label.num = 0;
                Label.Str[Label.num++] = text.Str[i + 3];
            }


            if (d_label.First_last & 1) {
                label_flag = 1;
                change = 0;
                store = 0;
            }
        }
    }
}

void short_X_PAD(int Frame_Length, int table_id) {
    int cnt;
    int i;
    static int first = 0;

    if (table_id == 1)
        cnt = 5;
    else
        cnt = 7;

    if (first == 0) {
        memset(&text, 0, sizeof(text));
    }

    if (f_pad.CI == 1) {
        if (first == 1) {
            LabelCheck();
            memset(&text, 0, sizeof(text));
        }

        first = 1;

    }

    if (first == 1) {
        for (i = 0; i < 4; i++) {
            text.Str[text.num++] = audio_frame[Frame_Length - cnt++];
        }
    }

}

void ancillary_data_decode(int Frame_Length, int table_id) {
    unsigned int temp;

    // ScaleFactor-CRC
    memcpy(sCRC_words.crc_word, &audio_frame[Frame_Length - 6], 4);
    sCRC_words.flag = 1;
    memset(&f_pad, 0, sizeof(f_pad));
    temp = audio_frame[Frame_Length - 2];
    f_pad.F_PAD_type = (temp >> 6) & 0x03;
    switch (f_pad.F_PAD_type) {
        case 0:
            f_pad.X_PAD_Ind = (temp >> 4) & 0x03;
            f_pad.ByteL_Ind = temp & 0x0f;
            break;
        case 2:
            f_pad.F_PAD_type_ext = (temp >> 4) & 0x03;
            switch (f_pad.F_PAD_type_ext) {
                case 0:
                    f_pad.IH_Cmd_field = temp & 0x0f;
                    break;
                case 1:
                    f_pad.M_S_flags = (temp >> 2) & 0x03;
                    f_pad.Origin = temp & 0x01;
                    break;
                case 2:
                case 3:
                    f_pad.Serial_Cmd_field = temp & 0x0f;
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }

    temp = audio_frame[Frame_Length - 1];
    f_pad.ByteL_data_field = (temp >> 2) & 0x3f;
    f_pad.CI = (temp >> 1) & 0x01;

    switch (f_pad.X_PAD_Ind) {
        case 0:
            break;
        case 1:
            short_X_PAD(Frame_Length, table_id);
            break;
        case 2:
//			variable_X_PAD(Frame_Length, table_id);
            break;
        case 3:
            break;
        default:
            break;
    }
}

void mp2DecoderInit() {
    sCRC_words.flag = 0;
    sN_ch = 0;
    sSampling = 0;
    sPCM_Length = 0;
    memset(sPCM_Frame, 0, sizeof(sPCM_Frame));
    memset(&Label, 0, sizeof(Label));
    label_flag = 0;
    Toggle = 2;
    change = 0;
    store = 0;
}

int decodeMp2Frame(unsigned char *in, int len, unsigned char *out, unsigned int *info) {
    int i;
    int bound = 0;
    int sblimit = 0;
    int table_id = 0;
    int sampling = 0;
    int pcmLength = 0;
    int nch = 0;
    short pcmFrame[1152 * 2];

    info[2] = 0;
    audio_buf_init(in, len);
    CRC_buf_init(in, len);
    head_decode();
    get_parameters(&nch, &sampling, &bound, &sblimit, &table_id);
    drop_bits(16);
    audio_data_decode(nch, &sampling, &pcmLength, bound, sblimit, table_id, pcmFrame);

    if (label_flag) {
        label_flag = 0;
        info[2] = 1;
    }
    info[0] = sampling;
    info[1] = nch;
    memcpy(out, pcmFrame, pcmLength * 2);
    return pcmLength * 2;
}

#ifdef __cplusplus
}
#endif
